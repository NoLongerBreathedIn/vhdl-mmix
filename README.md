This is a microcode implementation of MMIX.

The following things have not been written:  
Virtual address translation caches  
Memory cache  
The actual microcode

The microcode is very Harvard-architecture.

For information on how to write the microcode
(in other words, the micro-opcodes),
please see `cpu.vhdl`.
One thing that isn't covered there is where execution should start.
There should be a `PGO` to execute fetch/decode in microcode address 0,
and microcode for MMIX opcode n should start in location 256n+1.

When the execution finishes,
it should leave nominal time taken for this instruction in tregister 076,
and the result (the octabyte to store in memory or in `$X`) in register 29.
The address of the next instruction should be left in register 14.
(The address of the current instruction plus 1 will be found there
when execution starts after fetch/decode.)
There is (or will be) a 'check-for-trips-and-traps' routine,
and when calling it, store sensible values for `rX`, `rY`, and `rZ` in
registers 26-28.
It is permissible to require that register 26 starts out at 0 when executing
an instruction normally.

Register 30 is reserved for the contents of `rQ` at the time it was last read.
(Attempting to set `rQ` to `x` sets it instead to `x|rQ&~prQ`,
according to the documentation.
To do this takes five microinstructions.
(`MVO 2 30; SET 0 0xCB; SET 1 0x10` to set up
(register 2 is `ALUZ`, `0xCB` is the MMIX opcode for `ANDN`,
bregister 1 is `SRS`, `rQ` is special register 16, register 1 is `ALUY`,
register 4 is `SDR`, register 3 is `ALUX`, bregister 0 is `ALUS`,
and `0xC0` is the MMIX opcode for `OR`),
then `MVO 1 4; MVO 2 3; SET 0 0xC0; MVO 1 28; MVO 4 3` to complete)
so interrupts might be ignored by accident if they stay on for fewer than
five clock cycles, unless they are generated by microinstructions.)

This leaves six registers that are entirely general-purpose,
as well as wregister 0x7E. Registers 26 to 28 are almost general-purpose,
as the microarchitecture has no interrupts,
and bregister 0x63, wregisters 0x00, 0x22, and 0x7f, tregister 031,
and registers 1, 2, 6, 7, 9, and 13 can be used as temporary storage,
as long as they are reset to proper values before their effects are used.
Tregister 001 should be treated as inviolate
during execution of an instruction.

Stack overflow causes discard of overflowed addresses
and an OS trap if too many pops are attempted
(this is because `TRAP` has opcode 0).

